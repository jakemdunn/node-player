{"version":3,"sources":["app.js","ngPouch.js","ngRoute.js","ngStorage.js","socket.js"],"names":["app","angular","module","config","$routeProvider","$locationProvider","USER_ROLES","when","templateUrl","controller","data","authorizedRoles","user","admin","otherwise","redirectTo","html5Mode","run","$rootScope","$cookies","ngPouch","AuthService","AUTH_EVENTS","$on","loginSuccess","event","session","saveSettings","database","stayConnected","init","service","$timeout","$localStorage","db","PouchDB","remotedb","undefined","invokeApply","settings","username","password","status","localChanges","changeEvents","replicationToEvents","replicationFromEvents","docsSent","docsReceived","currentRetryDelay","maxRetryDelay","retryDelayInc","lastConnectionAttempt","publishInProgress","changes","replicationTo","replicationFrom","delayStatusPromise","retryPromise","publishPromise","this","loadSettings","loadStatus","trackChanges","initRobustSync","statusIcon","statusTitle","incrementLocalChanges","self","persistStatus","resetLocalChanges","storeChangeEvent","value","storeReplicationToEvent","storeReplicationFromEvent","pouchStatus","pouchSettings","publish","f","runFn","info","err","cancel","since","update_seq","live","on","getSettings","reset","destroy","then","disconnect","delay","cancelProgressiveRetry","progressiveRetry","attemptConnection","Date","flashSessionStatus","connect","maxOutProgressiveDelay","restartProgressiveDelay","s","setSessionStatus","delaySessionStatus","cancelSessionStatus","isKeyInEncryptionList","key","exclusiveDisable","indexOf","substr","recursiveObjectEncyptDecypt","obj","encptDecpytFunction","val","call","i","handleChanges","occurred_at","handleReplicationFrom","docs_written","handleReplicationTo","console","log","createRemoteDb","login","logoff","replicate","to","from","window","$RouteProvider","inherit","parent","extra","extend","Object","create","pathRegExp","path","opts","insensitive","caseInsensitiveMatch","ret","originalPath","regexp","keys","replace","_","slash","option","optional","star","push","name","RegExp","routes","route","routeCopy","copy","isUndefined","reloadOnSearch","redirectPath","length","params","$get","$location","$routeParams","$q","$injector","$templateRequest","$sce","switchRouteMatcher","m","exec","len","prepareRoute","$locationEvent","lastRoute","$route","current","preparedRoute","parseRoute","preparedRouteIsUpdateOnly","$$route","equals","pathParams","forceReload","$broadcast","defaultPrevented","preventDefault","commitRoute","nextRoute","isString","interpolate","search","url","template","locals","resolve","forEach","get","invoke","isDefined","isFunction","getTrustedResourceUrl","loadedTemplateUrl","all","error","match","string","result","split","segment","segmentMatch","join","reload","$evalAsync","updateParams","newParams","$routeMinErr","$RouteParamsProvider","ngViewFactory","$anchorScroll","$animate","restrict","terminal","priority","transclude","link","scope","$element","attr","ctrl","$transclude","cleanupLastView","previousLeaveAnimation","currentScope","$destroy","currentElement","leave","update","$template","newScope","$new","clone","enter","autoScrollExp","$eval","$emit","onloadExp","autoscroll","onload","ngViewFillContentFactory","$compile","$controller","html","contents","$scope","controllerAs","children","ngRouteModule","provider","$$minErr","directive","$inject","_storageFactory","storageType","$window","$log","_last$storage","_debounce","k","webStorage","warn","$storage","$default","items","$reset","slice","fromJson","getItem","$watch","setTimeout","v","setItem","toJson","removeItem","addEventListener","newValue","$apply","factory","defaultPrefix","asyncAngularify","socket","callback","args","arguments","apply","noop","options","ioSocket","io","prefix","defaultScope","addListener","eventName","__ng","addOnceListener","once","wrappedSocket","emit","lastIndex","removeListener","ev","fn","removeAllListeners","close","forward","events","Array","prefixedEvent","forwardBroadcast","prototype","unshift"],"mappings":"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","file":"modules.js","sourcesContent":["var app = angular.module( 'musicApp', [\n\t\t'ngCookies',\n\t\t'ngPouch',\n\t\t'ngRoute',\n\t\t'btford.socket-io',\n\t\t'angular-duration-format',\n\t])\n\t.config(['$routeProvider','$locationProvider','USER_ROLES',function($routeProvider,$locationProvider,USER_ROLES){\n\t\t$routeProvider\n\n\t\t\t.when('/', {\n\t\t\t\ttemplateUrl : 'views/pages/home.html',\n\t\t\t\tcontroller  : 'HomeController',\n\t\t\t\tdata: {\n\t\t\t\t\tauthorizedRoles: [USER_ROLES.user,USER_ROLES.admin]\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t.when('/login', {\n\t\t\t\ttemplateUrl : 'views/pages/login.html',\n\t\t\t\tcontroller  : 'LoginController'\n\t\t\t})\n\n\t\t\t.when('/log', {\n\t\t\t\ttemplateUrl : 'views/pages/log.html',\n\t\t\t\tcontroller  : 'LogController',\n\t\t\t\tdata: {\n\t\t\t\t\tauthorizedRoles: [USER_ROLES.user,USER_ROLES.admin]\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t.otherwise({\n\t\t\t\tredirectTo: '/login'\n\t\t\t});\n\n\t\t// use the HTML5 History API\n\t\t$locationProvider.html5Mode(true);\n\t}])\n\t.run(['$rootScope','$cookies','ngPouch','AuthService','AUTH_EVENTS',function ($rootScope,$cookies,ngPouch,AuthService,AUTH_EVENTS) {\n\n\t\t// Setup Pouch once we're authenticated\n\t\t$rootScope.$on(AUTH_EVENTS.loginSuccess,function(event,user){\n\t\t\t$cookies['AuthSession'] = user.session;\n\n\t\t\tngPouch.saveSettings({\n\t\t\t\tdatabase:'http://localhost:5984/songs',\n\t\t\t\tstayConnected:true\n\t\t\t});\n\n\t\t\tngPouch.init();\n\t\t});\n\n\t\t// Initiate our Authentication\n\t\tAuthService.init();\n\t}]);","'use strict';\n\nangular.module('ngPouch', ['ngStorage'])\n  .service('ngPouch', ['$timeout','$localStorage',function($timeout, $localStorage) {\n\n    var service =  {\n      // Databases\n      db: new PouchDB(\"LocalDB\"),\n      remotedb: undefined,\n\n      // Options\n      invokeApply: true,\n\n\n      // Persistent Settings\n      settings: {\n        database: undefined,\n        username: undefined,\n        password: undefined,\n        stayConnected: undefined\n      },\n\n      // Persistent Status\n      status: {\n        localChanges: 0,\n        changeEvents: {},\n        replicationToEvents: {},\n        replicationFromEvents: {}\n      },\n\n      // Session Status\n      session: {\n        // Session Stats\n        status: \"offline\",\n        docsSent: 0,\n        docsReceived: 0,\n        currentRetryDelay: 10,\n        maxRetryDelay: 60*1000*10,\n        retryDelayInc: 1000,\n        lastConnectionAttempt: undefined,\n        publishInProgress: false\n      },\n\n      // SPromises & Even Emitters\n      changes: undefined,\n      replicationTo: undefined,\n      replicationFrom: undefined,\n      delayStatusPromise: undefined,\n      retryPromise: undefined,\n      publishPromise: undefined,\n\n      /*\n       *  Initializers\n       *\n       */\n\n      init: function() {\n        // Load Persistent Data\n        this.loadSettings();\n        this.loadStatus();\n\n        // Start Session\n        this.trackChanges();\n        this.initRobustSync(1000);\n\n        // Had to use these functions somewhere\n        // to get WebStorm to turn green.\n        // This is a really silly use of them\n        return [this.statusIcon(), this.statusTitle()];\n      },\n\n\n      /*\n       *  storage aware accessors for settings and status\n       */\n\n      incrementLocalChanges: function() {\n        var self = this;\n        if( typeof self.status.localChanges === \"number\")\n        {\n          self.status.localChanges++;\n        } else {\n          self.status.localChanges = 1;\n        }\n        this.persistStatus();\n      },\n\n      resetLocalChanges: function() {\n        this.status.localChanges = 0;\n        this.persistStatus();\n      },\n\n      storeChangeEvent: function(value, event) {\n        var self = this;\n        if( typeof self.status.changeEvents === \"undefined\")\n        {\n          self.status.changeEvents = {}\n        }\n        self.status.changeEvents[event] = value;\n        self.persistStatus();\n      },\n\n      storeReplicationToEvent: function(value, event) {\n        var self = this;\n        if( typeof self.status.replicationToEvents === \"undefined\")\n        {\n          self.status.replicationToEvents = {}\n        }\n\n        self.status.replicationToEvents[event] = value;\n        self.persistStatus();\n      },\n\n      storeReplicationFromEvent: function(value, event) {\n        var self = this;\n        if( typeof self.status.replicationFromEvents === \"undefined\")\n        {\n          self.status.replicationFromEvents = {}\n        }\n        self.status.replicationFromEvents[event] = value;\n        self.persistStatus();\n      },\n\n      persistStatus: function() {\n        $localStorage.pouchStatus = this.status;\n      },\n\n      loadSettings: function() {\n        if (typeof $localStorage.pouchSettings !== \"undefined\") {\n          this.settings = $localStorage.pouchSettings;\n        }\n      },\n\n      loadStatus: function() {\n        if (typeof $localStorage.pouchStatus !== \"undefined\") {\n          this.status = $localStorage.pouchStatus\n        }\n      },\n\n      /*\n       *  Public Methods\n       */\n\n\n      publish: function(f) {\n        // Cancel previous publishers from other controllers\n        // Run the function immediately and then again on database changes\n        // Prevent from getting called while in progress\n\n        var self = this;\n        self.session.publishInProgress = false;\n\n        var runFn = function(info) {\n          if ( self.session.publishInProgress === false) {\n            self.session.publishInProgress = true;\n            f().finally(function() {\n              $timeout(function() {\n                self.session.publishInProgress=false;\n              }, 0, self.invokeApply);\n            });\n          }\n        };\n\n        self.db.info(function(err, info) {\n\n          if(typeof self.publishPromise !== \"undefined\") {\n            if(typeof self.publishPromise.cancel !== \"undefined\")\n            {\n              self.publishPromise.cancel();\n            }\n          }\n\n          self.publishPromise = self.db.changes({\n            since: (info.update_seq-1),\n            live: true\n          }).on('change', runFn);\n\n        });\n\n        runFn();\n      },\n\n      getSettings: function() {\n        return this.settings;\n      },\n\n      saveSettings: function(settings) {\n        //this.db.logout();\n        this.settings = settings;\n        $localStorage.pouchSettings = this.getSettings();\n        this.initRobustSync(1000);\n      },\n\n      localChanges: function() {\n        if (typeof this.status === \"undefined\")\n        {\n          return \"undefined\";\n        } else\n        {\n          return this.status.localChanges;\n        }\n      },\n\n      statusIcon: function() {\n        switch(this.session.status) {\n          case \"connecting\":\n            return \"ion-ios7-cloudy-night-outline\";\n          case \"online\":\n            return \"ion-ios7-cloud-outline\";\n          case \"offline\":\n            return \"ion-ios7-cloudy-night\";\n          case \"idle\":\n            return \"ion-ios7-cloud-outline\";\n          case \"receiving\":\n            return \"ion-ios7-cloud-download-outline\";\n          case \"sending\":\n            return \"ion-ios7-cloud-upload-outline\";\n          default:\n            return \"ion-alert-circled\";\n        }\n      },\n\n      statusTitle: function() {\n        switch(this.session.status) {\n          case \"online\":\n            return \"Connected\";\n          case \"connecting\":\n            return \"Trying to connect\";\n          case \"offline\":\n            return \"Not connected\";\n          case \"idle\":\n            return \"Connected\";\n          case \"receiving\":\n            return \"Receiving Data\";\n          case \"sending\":\n            return \"Sending Data\";\n          default:\n            return \"Unknown Status\";\n        }\n      },\n\n      // Destroy and recreated local db and changes db\n      reset: function() {\n        var self = this;\n        PouchDB.destroy(\"LocalDB\").then( function() {\n          $localStorage.pouchStatus = {};\n          $localStorage.session = {};\n          self.disconnect();\n          self.init();\n        });\n      },\n\n      /*\n       *  Private Methods\n       */\n\n\n      initRobustSync: function(delay) {\n        var self = this;\n        self.session.currentRetryDelay = delay;\n        self.cancelProgressiveRetry();\n\n        if (self.settings.stayConnected === true) {\n          self.progressiveRetry();\n        }\n      },\n\n      attemptConnection: function() {\n        var self = this;\n        self.session.lastConnectionAttempt = new Date();\n        self.flashSessionStatus(\"connecting\");\n        self.connect();\n      },\n\n\n      maxOutProgressiveDelay: function() {\n        this.initRobustSync(this.session.maxRetryDelay);\n      },\n\n      restartProgressiveDelay: function() {\n        if (this.session.status !== \"connecting\" &&\n          this.session.status !== \"offline\")\n        {\n          this.initRobustSync(1000);\n        }\n      },\n\n      cancelProgressiveRetry: function() {\n        var self = this;\n        if (typeof self.retryPromise === \"object\") {\n          $timeout.cancel(self.retryPromise);\n        }\n      },\n\n      progressiveRetry: function() {\n        var self = this;\n        if (self.session.currentRetryDelay < self.session.maxRetryDelay)\n        {\n          self.session.currentRetryDelay = self.session.currentRetryDelay + self.session.retryDelayInc;\n        }\n\n        self.retryPromise = $timeout( function() {\n          self.progressiveRetry();\n          self.attemptConnection();\n        }, self.session.currentRetryDelay, false)\n      },\n\n      flashSessionStatus: function(status) {\n        var self = this;\n        var s = self.session.status;\n        self.setSessionStatus(status);\n        self.delaySessionStatus(2000, s);\n      },\n\n      setSessionStatus: function(status) {\n        var self = this;\n        self.cancelSessionStatus();\n        $timeout(function() {\n          self.session.status = status;\n        },0,self.invokeApply);\n      },\n\n      delaySessionStatus: function(delay, status) {\n        var self = this;\n        self.cancelSessionStatus();\n        self.delayStatusPromise= $timeout(\n          function() {\n            self.setSessionStatus(status);\n          },delay, self.invokeApply);\n      },\n\n      cancelSessionStatus: function() {\n\n        var self = this;\n        if (typeof self.delayStatusPromise === \"object\")\n        {\n          $timeout.cancel(self.delayStatusPromise);\n        }\n      },\n\n      /**\n       * Check the key and value, if value is to encrypt returns true\n       * @param key The key in the doc\n       * @param value The value in the doc\n       * @returns {boolean} true if key is to encrypt\n       */\n      isKeyInEncryptionList: function(key,value){\n        var exclusiveDisable = [\n            'design_doc'\n        ];\n          //Exclude by you\n        if(exclusiveDisable.indexOf(key)){\n          return false;\n          //Internal field\n        }else if(key.substr(0,1) === '_') {\n          return false;\n        }else if (typeof value === 'function' ){\n          return false;\n        }else{\n          return true;\n        }\n      },\n\n      recursiveObjectEncyptDecypt: function (obj, encptDecpytFunction){\n        var self = this;\n        for (var key in obj){\n          var val = obj[key];\n          if(self.isKeyInEncryptionList(key,val)){\n\n              //Recusive call if object\n            if(typeof val === 'object'){\n              obj[key] = self.recursiveObjectEncyptDecypt.call(self,val,encptDecpytFunction);\n\n              //Call for each element of an array\n            }else if (typeof val === 'array'){\n              for (var i in val){\n                var arrVal = val[i]\n                val[i] = self.recursiveObjectEncyptDecypt.call(self,val[i],encptDecpytFunction);\n              }\n\n              //If normal val\n            }else {\n              obj[key] = encptDecpytFunction.call(this,val);\n            }\n          }\n          if (typeof val === 'function'){\n            delete obj[key];\n          }\n        }\n        return obj;\n      },\n      \n      trackChanges: function() {\n        var self = this;\n        if (typeof self.changes === \"object\") {\n          self.changes.cancel();\n        }\n        self.db.info()\n          .then( function(info) {\n            self.changes = self.db.changes({\n              since: info.update_seq,\n              live: true\n            })\n              .on('change', function(info) {self.handleChanges(info, \"change\")} )\n              .on('error', function(info) {self.handleChanges(info, \"error\")})\n              .on('complete', function(info) {self.handleChanges(info, \"complete\")})\n          });\n\n      },\n\n      handleChanges: function(info, event) {\n        var self = this;\n        info.occurred_at = new Date();\n        self.storeChangeEvent(info, event);\n        if (event === \"change\") {\n          $timeout(function() {\n            self.incrementLocalChanges();\n          }, 0, self.invokeApply);\n        }\n\n      },\n\n      handleReplicationFrom: function(info, event) {\n        var self = this;\n        info.occurred_at = new Date();\n        self.storeReplicationFromEvent(info, event);\n        switch (event) {\n          case \"uptodate\":\n            self.maxOutProgressiveDelay();\n            self.delaySessionStatus(800, \"idle\");\n            break;\n          case \"error\":\n            self.restartProgressiveDelay();\n            self.delaySessionStatus(800, \"offline\");\n            break;\n          case \"complete\":\n            //self.restartProgressiveDelay();\n            //self.delaySessionStatus(800, \"offline\");\n            break;\n          case \"change\":\n            self.maxOutProgressiveDelay();\n            if(info.docs_written > self.session.docsReceived){\n              self.session.docsReceived = info.docs_written;\n              self.setSessionStatus(\"receiving\");\n            }\n            break\n        }\n      },\n\n      handleReplicationTo: function(info, event) {\n        var self = this;\n        switch (event) {\n          case \"uptodate\":\n            self.maxOutProgressiveDelay();\n            self.resetLocalChanges();\n            self.delaySessionStatus(800, \"idle\");\n            break;\n          case \"error\":\n            self.restartProgressiveDelay();\n            self.delaySessionStatus(800, \"offline\");\n            break;\n          case \"complete\":\n            //self.restartProgressiveDelay();\n            //self.delaySessionStatus(800, \"offline\");\n            break;\n          case \"change\":\n            self.maxOutProgressiveDelay();\n            if(info.docs_written > self.session.docsSent){\n              self.session.docsSent = info.docs_written;\n              self.setSessionStatus(\"sending\");\n            }\n            break\n        }\n        info.occurred_at = new Date();\n        this.storeReplicationToEvent(info, event);\n      },\n\n\n      // Disconnect from Remote Database\n      disconnect: function() {\n        var self = this;\n        if(typeof self.session.replicationTo === \"object\") {\n          console.log(\"disconnect to\");\n          self.session.replicationTo.cancel();\n        }\n\n        if(typeof self.session.replicationFrom === \"object\") {\n          console.log(\"disconnect from\");\n          self.session.replicationFrom.cancel();\n        }\n      },\n\n      createRemoteDb: function() {\n        var self = this;\n\n        if (typeof self.settings.database === \"string\")\n        {\n          // var options = (typeof self.settings.cookie === 'string') ? {headers: {'AuthSession': self.settings.cookie}} : null;\n\n          self.remotedb = new PouchDB(this.settings.database);\n          if (typeof self.settings.username === \"string\" && typeof self.settings.password === \"string\")\n          {\n            self.remotedb.login(this.settings.username, this.settings.password, function (err, response) {})\n          }\n        }\n      },\n\n      logoff: function() {\n        this.settings['stayConnected']=false;\n        $localStorage.pouchSettings = this.getSettings();\n\n        // Throwing the kitchen sync to break the live sync\n        this.cancelProgressiveRetry();\n        this.disconnect();\n        this.createRemoteDb();\n        this.delaySessionStatus(800, \"offline\");\n      },\n\n      // Connect to Remote Database and Start Replication\n      connect: function() {\n        var self = this;\n        self.session.docsSent = 0;\n        self.session.docsReceived = 0;\n        self.disconnect();\n        self.createRemoteDb();\n        self.session.replicationTo = self.db.replicate.to(self.remotedb, {live: true})\n          .on('change', function(info)   {self.handleReplicationTo(info, \"change\")})\n          .on('uptodate', function(info) {self.handleReplicationTo(info, \"uptodate\")})\n          .on('error', function(info)    {self.handleReplicationTo(info, \"error\")})\n          .on('complete', function(info) {self.handleReplicationTo(info, \"complete\")});\n\n        self.session.replicationFrom = self.db.replicate.from(self.remotedb, {live: true})\n          .on('change', function(info)   {self.handleReplicationFrom(info, \"change\")})\n          .on('uptodate', function(info) {self.handleReplicationFrom(info, \"uptodate\")})\n          .on('error', function(info)    {self.handleReplicationFrom(info, \"error\")})\n          .on('complete', function(info) {self.handleReplicationFrom(info, \"complete\")});\n      }\n\n\n    };\n\n    // service.init();\n    return service\n  }]);","/**\n * @license AngularJS v1.3.15\n * (c) 2010-2014 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\n/**\n * @ngdoc module\n * @name ngRoute\n * @description\n *\n * # ngRoute\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n *\n * <div doc-module-components=\"ngRoute\"></div>\n */\n /* global -ngRouteModule */\nvar ngRouteModule = angular.module('ngRoute', ['ng']).\n                        provider('$route', $RouteProvider),\n    $routeMinErr = angular.$$minErr('ngRoute');\n\n/**\n * @ngdoc provider\n * @name $routeProvider\n *\n * @description\n *\n * Used for configuring routes.\n *\n * ## Example\n * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.\n *\n * ## Dependencies\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider() {\n  function inherit(parent, extra) {\n    return angular.extend(Object.create(parent), extra);\n  }\n\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#when\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain named groups starting with a colon and ending with a star:\n   *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashes/edit` and extract:\n   *\n   *    * `color: brown`\n   *    * `largecode: code/with/slashes`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` – `{(string|function()=}` – Controller fn that should be associated with\n   *      newly created scope or the name of a {@link angular.Module#controller registered\n   *      controller} if passed as a string.\n   *    - `controllerAs` – `{string=}` – A controller alias name. If present the controller will be\n   *      published to scope under the `controllerAs` name.\n   *    - `template` – `{string=|function()=}` – html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `templateUrl` – `{string=|function()=}` – path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, the router\n   *      will wait for them all to be resolved or one to be rejected before the controller is\n   *      instantiated.\n   *      If all the promises are resolved successfully, the values of the resolved promises are\n   *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is\n   *      fired. If any of the promises are rejected the\n   *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired. The map object\n   *      is:\n   *\n   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link auto.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is\n   *        resolved before its value is injected into the controller. Be aware that\n   *        `ngRoute.$routeParams` will still refer to the previous route within these resolve\n   *        functions.  Use `$route.current.params` to access the new route parameters, instead.\n   *\n   *    - `redirectTo` – {(string|function())=} – value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.path()` and `$location.search()`.\n   *\n   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only `$location.search()`\n   *      or `$location.hash()` changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    //copy original route object to preserve params inherited from proto chain\n    var routeCopy = angular.copy(route);\n    if (angular.isUndefined(routeCopy.reloadOnSearch)) {\n      routeCopy.reloadOnSearch = true;\n    }\n    if (angular.isUndefined(routeCopy.caseInsensitiveMatch)) {\n      routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;\n    }\n    routes[path] = angular.extend(\n      routeCopy,\n      path && pathRegExp(path, routeCopy)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length - 1] == '/')\n            ? path.substr(0, path.length - 1)\n            : path + '/';\n\n      routes[redirectPath] = angular.extend(\n        {redirectTo: path},\n        pathRegExp(redirectPath, routeCopy)\n      );\n    }\n\n    return this;\n  };\n\n  /**\n   * @ngdoc property\n   * @name $routeProvider#caseInsensitiveMatch\n   * @description\n   *\n   * A boolean property indicating if routes defined\n   * using this provider should be matched using a case insensitive\n   * algorithm. Defaults to `false`.\n   */\n  this.caseInsensitiveMatch = false;\n\n   /**\n    * @param path {string} path\n    * @param opts {Object} options\n    * @return {?Object}\n    *\n    * @description\n    * Normalizes the given path, returning a regular expression\n    * and the original path.\n    *\n    * Inspired by pathRexp in visionmedia/express/lib/utils.js.\n    */\n  function pathRegExp(path, opts) {\n    var insensitive = opts.caseInsensitiveMatch,\n        ret = {\n          originalPath: path,\n          regexp: path\n        },\n        keys = ret.keys = [];\n\n    path = path\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)([\\?\\*])?/g, function(_, slash, key, option) {\n        var optional = option === '?' ? option : null;\n        var star = option === '*' ? option : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+?)' || '([^/]+)')\n          + (optional || '')\n          + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/$\\*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $routeProvider#otherwise\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object|string} params Mapping information to be assigned to `$route.current`.\n   * If called with a string, the value maps to `redirectTo`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    if (typeof params === 'string') {\n      params = {redirectTo: params};\n    }\n    this.when(null, params);\n    return this;\n  };\n\n\n  this.$get = ['$rootScope',\n               '$location',\n               '$routeParams',\n               '$q',\n               '$injector',\n               '$templateRequest',\n               '$sce',\n      function($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {\n\n    /**\n     * @ngdoc service\n     * @name $route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as define in route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     * @property {Object} routes Object with all route configuration Objects as its properties.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with the\n     * {@link ngRoute.directive:ngView `ngView`} directive and the\n     * {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n     * This example shows how changing the URL hash causes the `$route` to match a route against the\n     * URL, and the `ngView` pulls in the partial.\n     *\n     * <example name=\"$route-service\" module=\"ngRouteExample\"\n     *          deps=\"angular-route.js\" fixBase=\"true\">\n     *   <file name=\"index.html\">\n     *     <div ng-controller=\"MainController\">\n     *       Choose:\n     *       <a href=\"Book/Moby\">Moby</a> |\n     *       <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n     *       <a href=\"Book/Gatsby\">Gatsby</a> |\n     *       <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n     *       <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n     *\n     *       <div ng-view></div>\n     *\n     *       <hr />\n     *\n     *       <pre>$location.path() = {{$location.path()}}</pre>\n     *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n     *       <pre>$route.current.params = {{$route.current.params}}</pre>\n     *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n     *       <pre>$routeParams = {{$routeParams}}</pre>\n     *     </div>\n     *   </file>\n     *\n     *   <file name=\"book.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *   </file>\n     *\n     *   <file name=\"chapter.html\">\n     *     controller: {{name}}<br />\n     *     Book Id: {{params.bookId}}<br />\n     *     Chapter Id: {{params.chapterId}}\n     *   </file>\n     *\n     *   <file name=\"script.js\">\n     *     angular.module('ngRouteExample', ['ngRoute'])\n     *\n     *      .controller('MainController', function($scope, $route, $routeParams, $location) {\n     *          $scope.$route = $route;\n     *          $scope.$location = $location;\n     *          $scope.$routeParams = $routeParams;\n     *      })\n     *\n     *      .controller('BookController', function($scope, $routeParams) {\n     *          $scope.name = \"BookController\";\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *      .controller('ChapterController', function($scope, $routeParams) {\n     *          $scope.name = \"ChapterController\";\n     *          $scope.params = $routeParams;\n     *      })\n     *\n     *     .config(function($routeProvider, $locationProvider) {\n     *       $routeProvider\n     *        .when('/Book/:bookId', {\n     *         templateUrl: 'book.html',\n     *         controller: 'BookController',\n     *         resolve: {\n     *           // I will cause a 1 second delay\n     *           delay: function($q, $timeout) {\n     *             var delay = $q.defer();\n     *             $timeout(delay.resolve, 1000);\n     *             return delay.promise;\n     *           }\n     *         }\n     *       })\n     *       .when('/Book/:bookId/ch/:chapterId', {\n     *         templateUrl: 'chapter.html',\n     *         controller: 'ChapterController'\n     *       });\n     *\n     *       // configure html5 to get links working on jsfiddle\n     *       $locationProvider.html5Mode(true);\n     *     });\n     *\n     *   </file>\n     *\n     *   <file name=\"protractor.js\" type=\"protractor\">\n     *     it('should load and compile correct template', function() {\n     *       element(by.linkText('Moby: Ch1')).click();\n     *       var content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller\\: ChapterController/);\n     *       expect(content).toMatch(/Book Id\\: Moby/);\n     *       expect(content).toMatch(/Chapter Id\\: 1/);\n     *\n     *       element(by.partialLinkText('Scarlet')).click();\n     *\n     *       content = element(by.css('[ng-view]')).getText();\n     *       expect(content).toMatch(/controller\\: BookController/);\n     *       expect(content).toMatch(/Book Id\\: Scarlet/);\n     *     });\n     *   </file>\n     * </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeStart\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occur.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * The route change (and the `$location` change that triggered it) can be prevented\n     * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}\n     * for more details about event object.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeSuccess\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route dependencies are resolved.\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is\n     * first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeChangeError\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if any of the resolve promises are rejected.\n     *\n     * @param {Object} angularEvent Synthetic event object\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.\n     */\n\n    /**\n     * @ngdoc event\n     * @name $route#$routeUpdate\n     * @eventType broadcast on root scope\n     * @description\n     *\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     */\n\n    var forceReload = false,\n        preparedRoute,\n        preparedRouteIsUpdateOnly,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name $route#reload\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope and reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n            $rootScope.$evalAsync(function() {\n              // Don't support cancellation of a reload for now...\n              prepareRoute();\n              commitRoute();\n            });\n          },\n\n          /**\n           * @ngdoc method\n           * @name $route#updateParams\n           *\n           * @description\n           * Causes `$route` service to update the current URL, replacing\n           * current route parameters with those specified in `newParams`.\n           * Provided property names that match the route's path segment\n           * definitions will be interpolated into the location's path, while\n           * remaining properties will be treated as query params.\n           *\n           * @param {!Object<string, string>} newParams mapping of URL parameter names to values\n           */\n          updateParams: function(newParams) {\n            if (this.current && this.current.$$route) {\n              newParams = angular.extend({}, this.current.params, newParams);\n              $location.path(interpolate(this.current.$$route.originalPath, newParams));\n              // interpolate modifies newParams, only query params are left\n              $location.search(newParams);\n            } else {\n              throw $routeMinErr('norout', 'Tried updating route when with no current route');\n            }\n          }\n        };\n\n    $rootScope.$on('$locationChangeStart', prepareRoute);\n    $rootScope.$on('$locationChangeSuccess', commitRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function prepareRoute($locationEvent) {\n      var lastRoute = $route.current;\n\n      preparedRoute = parseRoute();\n      preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route\n          && angular.equals(preparedRoute.pathParams, lastRoute.pathParams)\n          && !preparedRoute.reloadOnSearch && !forceReload;\n\n      if (!preparedRouteIsUpdateOnly && (lastRoute || preparedRoute)) {\n        if ($rootScope.$broadcast('$routeChangeStart', preparedRoute, lastRoute).defaultPrevented) {\n          if ($locationEvent) {\n            $locationEvent.preventDefault();\n          }\n        }\n      }\n    }\n\n    function commitRoute() {\n      var lastRoute = $route.current;\n      var nextRoute = preparedRoute;\n\n      if (preparedRouteIsUpdateOnly) {\n        lastRoute.params = nextRoute.params;\n        angular.copy(lastRoute.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', lastRoute);\n      } else if (nextRoute || lastRoute) {\n        forceReload = false;\n        $route.current = nextRoute;\n        if (nextRoute) {\n          if (nextRoute.redirectTo) {\n            if (angular.isString(nextRoute.redirectTo)) {\n              $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params)\n                       .replace();\n            } else {\n              $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search()))\n                       .replace();\n            }\n          }\n        }\n\n        $q.when(nextRoute).\n          then(function() {\n            if (nextRoute) {\n              var locals = angular.extend({}, nextRoute.resolve),\n                  template, templateUrl;\n\n              angular.forEach(locals, function(value, key) {\n                locals[key] = angular.isString(value) ?\n                    $injector.get(value) : $injector.invoke(value, null, null, key);\n              });\n\n              if (angular.isDefined(template = nextRoute.template)) {\n                if (angular.isFunction(template)) {\n                  template = template(nextRoute.params);\n                }\n              } else if (angular.isDefined(templateUrl = nextRoute.templateUrl)) {\n                if (angular.isFunction(templateUrl)) {\n                  templateUrl = templateUrl(nextRoute.params);\n                }\n                templateUrl = $sce.getTrustedResourceUrl(templateUrl);\n                if (angular.isDefined(templateUrl)) {\n                  nextRoute.loadedTemplateUrl = templateUrl;\n                  template = $templateRequest(templateUrl);\n                }\n              }\n              if (angular.isDefined(template)) {\n                locals['$template'] = template;\n              }\n              return $q.all(locals);\n            }\n          }).\n          // after route change\n          then(function(locals) {\n            if (nextRoute == $route.current) {\n              if (nextRoute) {\n                nextRoute.locals = locals;\n                angular.copy(nextRoute.params, $routeParams);\n              }\n              $rootScope.$broadcast('$routeChangeSuccess', nextRoute, lastRoute);\n            }\n          }, function(error) {\n            if (nextRoute == $route.current) {\n              $rootScope.$broadcast('$routeChangeError', nextRoute, lastRoute, error);\n            }\n          });\n      }\n    }\n\n\n    /**\n     * @returns {Object} the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      angular.forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: angular.extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns {string} interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      angular.forEach((string || '').split(':'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(?:[?*])?(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\nngRouteModule.provider('$routeParams', $RouteParamsProvider);\n\n\n/**\n * @ngdoc service\n * @name $routeParams\n * @requires $route\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * ```js\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}\n * ```\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive('ngView', ngViewFactory);\nngRouteModule.directive('ngView', ngViewFillContentFactory);\n\n\n/**\n * @ngdoc directive\n * @name ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * enter - animation is used to bring new content into the browser.\n * leave - animation is used to animate existing content away.\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @priority 400\n * @param {string=} onload Expression to evaluate whenever the view updates.\n *\n * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the view is updated.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated\n *                    as an expression yields a truthy value.\n * @example\n    <example name=\"ngView-directive\" module=\"ngViewExample\"\n             deps=\"angular-route.js;angular-animate.js\"\n             animations=\"true\" fixBase=\"true\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCtrl as main\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div class=\"view-animate-container\">\n            <div ng-view class=\"view-animate\"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name=\"chapter.html\">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name=\"animations.css\">\n        .view-animate-container {\n          position:relative;\n          height:100px!important;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .view-animate {\n          padding:10px;\n        }\n\n        .view-animate.ng-enter, .view-animate.ng-leave {\n          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .view-animate.ng-enter {\n          left:100%;\n        }\n        .view-animate.ng-enter.ng-enter-active {\n          left:0;\n        }\n        .view-animate.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])\n          .config(['$routeProvider', '$locationProvider',\n            function($routeProvider, $locationProvider) {\n              $routeProvider\n                .when('/Book/:bookId', {\n                  templateUrl: 'book.html',\n                  controller: 'BookCtrl',\n                  controllerAs: 'book'\n                })\n                .when('/Book/:bookId/ch/:chapterId', {\n                  templateUrl: 'chapter.html',\n                  controller: 'ChapterCtrl',\n                  controllerAs: 'chapter'\n                });\n\n              $locationProvider.html5Mode(true);\n          }])\n          .controller('MainCtrl', ['$route', '$routeParams', '$location',\n            function($route, $routeParams, $location) {\n              this.$route = $route;\n              this.$location = $location;\n              this.$routeParams = $routeParams;\n          }])\n          .controller('BookCtrl', ['$routeParams', function($routeParams) {\n            this.name = \"BookCtrl\";\n            this.params = $routeParams;\n          }])\n          .controller('ChapterCtrl', ['$routeParams', function($routeParams) {\n            this.name = \"ChapterCtrl\";\n            this.params = $routeParams;\n          }]);\n\n      </file>\n\n      <file name=\"protractor.js\" type=\"protractor\">\n        it('should load and compile correct template', function() {\n          element(by.linkText('Moby: Ch1')).click();\n          var content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller\\: ChapterCtrl/);\n          expect(content).toMatch(/Book Id\\: Moby/);\n          expect(content).toMatch(/Chapter Id\\: 1/);\n\n          element(by.partialLinkText('Scarlet')).click();\n\n          content = element(by.css('[ng-view]')).getText();\n          expect(content).toMatch(/controller\\: BookCtrl/);\n          expect(content).toMatch(/Book Id\\: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngView#$viewContentLoaded\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = ['$route', '$anchorScroll', '$animate'];\nfunction ngViewFactory($route, $anchorScroll, $animate) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 400,\n    transclude: 'element',\n    link: function(scope, $element, attr, ctrl, $transclude) {\n        var currentScope,\n            currentElement,\n            previousLeaveAnimation,\n            autoScrollExp = attr.autoscroll,\n            onloadExp = attr.onload || '';\n\n        scope.$on('$routeChangeSuccess', update);\n        update();\n\n        function cleanupLastView() {\n          if (previousLeaveAnimation) {\n            $animate.cancel(previousLeaveAnimation);\n            previousLeaveAnimation = null;\n          }\n\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if (currentElement) {\n            previousLeaveAnimation = $animate.leave(currentElement);\n            previousLeaveAnimation.then(function() {\n              previousLeaveAnimation = null;\n            });\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (angular.isDefined(template)) {\n            var newScope = scope.$new();\n            var current = $route.current;\n\n            // Note: This will also link all children of ng-view that were contained in the original\n            // html. If that content contains controllers, ... they could pollute/change the scope.\n            // However, using ng-view on an element with additional content does not make sense...\n            // Note: We can't remove them in the cloneAttchFn of $transclude as that\n            // function is called before linking the content, which would apply child\n            // directives to non existing elements.\n            var clone = $transclude(newScope, function(clone) {\n              $animate.enter(clone, null, currentElement || $element).then(function onNgViewEnter() {\n                if (angular.isDefined(autoScrollExp)\n                  && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n              });\n              cleanupLastView();\n            });\n\n            currentElement = clone;\n            currentScope = current.scope = newScope;\n            currentScope.$emit('$viewContentLoaded');\n            currentScope.$eval(onloadExp);\n          } else {\n            cleanupLastView();\n          }\n        }\n    }\n  };\n}\n\n// This directive is called during the $transclude call of the first `ngView` directive.\n// It will replace and compile the content of the element with the loaded template.\n// We need this directive so that the element content is already filled when\n// the link function of another directive on the same element as ngView\n// is called.\nngViewFillContentFactory.$inject = ['$compile', '$controller', '$route'];\nfunction ngViewFillContentFactory($compile, $controller, $route) {\n  return {\n    restrict: 'ECA',\n    priority: -400,\n    link: function(scope, $element) {\n      var current = $route.current,\n          locals = current.locals;\n\n      $element.html(locals.$template);\n\n      var link = $compile($element.contents());\n\n      if (current.controller) {\n        locals.$scope = scope;\n        var controller = $controller(current.controller, locals);\n        if (current.controllerAs) {\n          scope[current.controllerAs] = controller;\n        }\n        $element.data('$ngControllerController', controller);\n        $element.children().data('$ngControllerController', controller);\n      }\n\n      link(scope);\n    }\n  };\n}\n\n\n})(window, window.angular);","'use strict';\n\n(function() {\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    angular.module('ngStorage', []).\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    factory('$localStorage', _storageFactory('localStorage')).\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    factory('$sessionStorage', _storageFactory('sessionStorage'));\n\n    function _storageFactory(storageType) {\n        return [\n            '$rootScope',\n            '$window',\n            '$log',\n\n            function(\n                $rootScope,\n                $window,\n                $log\n            ){\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                var webStorage = $window[storageType] || ($log.warn('This browser does not support Web Storage!'), {}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = items[k]);\n                            }\n\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || delete $storage[k];\n                            }\n\n                            return $storage.$default(items);\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                for (var i = 0, k; i < webStorage.length; i++) {\n                    // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                    (k = webStorage.key(i)) && 'ngStorage-' === k.slice(0, 10) && ($storage[k.slice(10)] = angular.fromJson(webStorage.getItem(k)));\n                }\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = setTimeout(function() {\n                        _debounce = null;\n\n                        if (!angular.equals($storage, _last$storage)) {\n                            angular.forEach($storage, function(v, k) {\n                                angular.isDefined(v) && '$' !== k[0] && webStorage.setItem('ngStorage-' + k, angular.toJson(v));\n\n                                delete _last$storage[k];\n                            });\n\n                            for (var k in _last$storage) {\n                                webStorage.removeItem('ngStorage-' + k);\n                            }\n\n                            _last$storage = angular.copy($storage);\n                        }\n                    }, 100));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                'localStorage' === storageType && $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if ('ngStorage-' === event.key.slice(0, 10)) {\n                        event.newValue ? $storage[event.key.slice(10)] = angular.fromJson(event.newValue) : delete $storage[event.key.slice(10)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                return $storage;\n            }\n        ];\n    }\n\n})();","/*\n * @license\n * angular-socket-io v0.7.0\n * (c) 2014 Brian Ford http://briantford.com\n * License: MIT\n */\n\nangular.module('btford.socket-io', []).\n  provider('socketFactory', function () {\n\n    'use strict';\n\n    // when forwarding events, prefix the event name\n    var defaultPrefix = 'socket:',\n      ioSocket;\n\n    // expose to provider\n    this.$get = ['$rootScope', '$timeout', function ($rootScope, $timeout) {\n\n      var asyncAngularify = function (socket, callback) {\n        return callback ? function () {\n          var args = arguments;\n          $timeout(function () {\n            callback.apply(socket, args);\n          }, 0);\n        } : angular.noop;\n      };\n\n      return function socketFactory (options) {\n        options = options || {};\n        var socket = options.ioSocket || io.connect();\n        var prefix = options.prefix === undefined ? defaultPrefix : options.prefix ;\n        var defaultScope = options.scope || $rootScope;\n\n        var addListener = function (eventName, callback) {\n          socket.on(eventName, callback.__ng = asyncAngularify(socket, callback));\n        };\n\n        var addOnceListener = function (eventName, callback) {\n          socket.once(eventName, callback.__ng = asyncAngularify(socket, callback));\n        };\n\n        var wrappedSocket = {\n          on: addListener,\n          addListener: addListener,\n          once: addOnceListener,\n\n          emit: function (eventName, data, callback) {\n            var lastIndex = arguments.length - 1;\n            var callback = arguments[lastIndex];\n            if(typeof callback == 'function') {\n              callback = asyncAngularify(socket, callback);\n              arguments[lastIndex] = callback;\n            }\n            return socket.emit.apply(socket, arguments);\n          },\n\n          removeListener: function (ev, fn) {\n            if (fn && fn.__ng) {\n              arguments[1] = fn.__ng;\n            }\n            return socket.removeListener.apply(socket, arguments);\n          },\n\n          removeAllListeners: function() {\n            return socket.removeAllListeners.apply(socket, arguments);\n          },\n\n          disconnect: function (close) {\n            return socket.disconnect(close);\n          },\n\n          connect: function() {\n            return socket.connect();\n          },\n\n          // when socket.on('someEvent', fn (data) { ... }),\n          // call scope.$broadcast('someEvent', data)\n          forward: function (events, scope) {\n            if (events instanceof Array === false) {\n              events = [events];\n            }\n            if (!scope) {\n              scope = defaultScope;\n            }\n            events.forEach(function (eventName) {\n              var prefixedEvent = prefix + eventName;\n              var forwardBroadcast = asyncAngularify(socket, function () {\n                Array.prototype.unshift.call(arguments, prefixedEvent);\n                scope.$broadcast.apply(scope, arguments);\n              });\n              scope.$on('$destroy', function () {\n                socket.removeListener(eventName, forwardBroadcast);\n              });\n              socket.on(eventName, forwardBroadcast);\n            });\n          }\n        };\n\n        return wrappedSocket;\n      };\n    }];\n  });\n"],"sourceRoot":"/source/"}